#python2
# coding: utf-8
# 3:33 PM 12/8/2015
from __future__ import division

import time
import xml.etree.ElementTree as ET
import sys
import argparse
from PIL import Image
import os
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import numpy as np
from tifffile import imsave


'''
This program takes the raw files generated by ThorImageLS and
returns a tiff stack to the experiment directory, complete with
averaged and summed preview files.

This is a simple hack that requires the raw file and the
`Experiment.xml` to be located in the same directory.

This program calculates the number of channels from the available
number of wavelengths declared in `Experiment.xml`. It takes
the width and height and frames from that file as well.

Typical usage looks something like this:

`> for /f %f in ('dir /s /b Ima*.RAW') do Convert_RAW.py -f %f`
Basically the above command is run in the root of the data directory,
the Windows for loop returns a list of files of the form `Ima*.RAW`,
and then passes the complete filename (including path) to the python
program. This program outputs to the same directory as the file that
it took in, so the complete path spec is important!

IMPORTANT: I have hard coded a gap of 4 channels because it seems
despite having 2 PMTs there are always 2 blank channels being recorded!?

'''

parser = argparse.ArgumentParser(description='convert RAW to tiff')
parser.add_argument("-f", "--file", default = "Image_0001_0001.raw")

parser.add_argument("-m",
                "--method",
                default = 'none',
                help = "numpy method to use for creating summary image")

parser.add_argument("--channels",
                nargs = "*",
                default = ["G", "R", "", ""],
                help = "Use a single character to specify the channel "
                        "colours in the order that they appear on  the "
                        "capture device. Default: [\"G\", \"R\", \"\", \"\"]"
                    )

def num(s):
        try:
            return int(s)
        except ValueError:
            return float(s)

def main(filename="", chan = ["G", "R", "", ""], method = 'sum'):

    filename =  filename.replace("\\", "/")
    print filename
    inpath = os.path.split(filename)[0]
    tiffpath = os.path.join(inpath, "tiff")
    summarypath = os.path.join(inpath, "summary")

    basename = os.path.split(inpath)[1]

    #the method to use to create summary
    methods = {
        'sum' : np.sum,
        'min' : np.min,
        'max' : np.max,
        'avg' : np.mean,
        'std' : np.std,
        'none': None,
    }

    if not(os.path.exists(tiffpath)):
        os.makedirs(tiffpath)
    print tiffpath

    if not(os.path.exists(summarypath)):
        os.makedirs(summarypath)
    print summarypath

    try:
        xmlfile = "Experiment.xml"
        XMLtree = ET.parse(os.path.join(inpath, xmlfile))

        root = XMLtree.getroot()

        name = root.find("Name").attrib['name']
        frames = num(root.find("Streaming").attrib['frames'])
        width = num(root.find("LSM").attrib['pixelX'])
        height = num(root.find("LSM").attrib['pixelY'])
        N_chan = len(root.find("Wavelengths").findall('Wavelength'))


        print "\t\tframes: ", frames
        print "\t\twidth: ", width
        print "\t\theight: ", height
        print "\t\tN_chan: ", N_chan

    except:
        print filename
        print "\t\tThis is not the directory you are looking for"

    if any([name in f for f in os.listdir(tiffpath)]):
        print [name in f for f in os.listdir(tiffpath)]
        print "tiffs already found"
        quit()

    img = np.fromfile(filename, dtype='<u2')

    gap = width*height*(N_chan+2)
    print "\t\tgap: ", gap
    print "\t\tcalculated images per channel: ", len(img) / gap

    img = np.reshape(img, (-1, width, height))

    for i in xrange(4):
        if chan[i]:
            channel = img[i::4]

            mean = np.mean(channel, axis = (1,2))
            np.savetxt(os.path.join(summarypath,'%s_F_%s.txt' %(name, chan[i])),
                mean, fmt ="%3.5g")

            plt.plot(mean, color = chan[i])
            plt.ylabel("mean fluorescence")
            plt.xlabel("frame")
            plt.savefig(os.path.join(summarypath,'%s_F_%savg.pdf' %(name, chan[i])))
            plt.close()

            imsave(os.path.join(tiffpath,
                    "%s_Chan%s_mov.tiff" %(name, chan[i])),
                    channel)

            if methods[method]:
                imsave(os.path.join(tiffpath,
                        "%s_Chan%s_%s.tiff" %(name, chan[i], method)),
                        methods[method](channel, axis = 0))

    with open(os.path.join(inpath,'timestamp.txt'), 'w') as f:
        f.write(time.ctime(os.path.getmtime(filename)))

    print "\t\tconverted: ", filename

if __name__ == "__main__":
    args=parser.parse_args()

    main(args.file,
        method = args.method,
        )

    print "--done"
